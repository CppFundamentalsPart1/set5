1. what differences exist between pointer variables and arrays;
    The array gives the location in memory where the array starts. From there the ident variable can be used to tell the computer how many steps from the start of the array the computer needs to look in the memory. So array[3] tells the computer to look at the value stored in the memory 3 steps away from the start of the array (so its forth element). Pointers work differently in the sense that they point at a certain point in the memory and tell the computer what is there. So *ptr = &array will again lead the computer the starting point of “array” but now by going to a variable that points at the starting point of array.

2. what differences exist between pointer variables and reference variables;
    a reference gives the address location of a certain variable or object and is thus linked to that variable or object. Once initialised it can not be changed to an other variable . A pointer however just points at the part of the memory to where it is told to point too. In our program we can first tell a pointer to point at a certain point of the memory and later tell it to point at an other point in the memory without any issues. The pointer will simple change values. With a reference this would not be possible. Other differences that exists between a pointer variable and a reference variable is that the reference variable needs to be initialised in mediately, where that is not the case for a pointer and a pointer can have a NULL value where a reference can not.

3. how element [3][2] is reached
  a: for the variable `int array[20][30]';
      The variable ‘int array[20][30]’ is a 2-dimensional array. The name array tells the memory address where the information is stored and then it contains 20 elements that each contain 30 integer values. With array[3][2] the computer will go the start of the array, then go 3 indent steps further (so ending at its forth element) and from there take the value that is stored two places next to its starting location (the third value of the fourth array).

  b: for the variable `int *pointer[20]';
      The variable ‘int *pointer[20]’ creates an array of 20 pointers to integers. With pointer[3][2] we will go the 4 forth element of the array where a pointer to an integer is stored and tell that pointer to indent 2 steps from the starting location where it is pointing to. This will return the third element.

4. what is meant by `pointer arithmetic';
    with pointer arithmetics we can tell a pointer to look n steps beyonds its starting location. The size of each step is equal to type of the pointer. Taking the example of the lecture slides, lets assume we have int count[5], int *left = count and int *right = count + 2. now count is an array of 6 integers, left is a pointer to an integer pointing at the starting point of count and right is a pointer to an integer pointing two integer steps after the starting point of the array named count. Now if we would use int x = left + 2 we will declare a variable x that gets the value that is sorted two integer steps after that where left is pointing to. So in this case we would have that x == right == count[2] similarly we have that count[5] == left + 5 == right + 3 and count[1] == left + 1 == right - 1. Sow with pointer arithmetic we can at steps or subtract extra “memory steps” to the starting point of the pointer to excess different parts of the memory.